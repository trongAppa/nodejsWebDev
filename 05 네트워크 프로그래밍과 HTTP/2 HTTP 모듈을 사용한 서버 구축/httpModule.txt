HTTP 모듈을 사용한 서버 구축
Node.js의 내장 모듈인 http 모듈을 사용하여 간단한 HTTP 서버를 구축하는 방법

HTTP 모듈
- Node.js에서 기본적으로 제공되는 모듈로, HTTP 서버와 클라이언트를 만들 수 있는 기능을 제공

1. HTTP 모듈을 사용하여 서버를 생성하는 방법을 학습할 것
- http.createServer() 메서드를 사용하여 서버를 생성하고, 콜백 함수를 등록하여 요청과 응답을 처리

2. 서버의 요청과 응답에 대한 처리 방법을 다룰 것
- 요청이 들어오면 콜백 함수가 실행되며, 요청 객체와 응답 객체를 통해 클라이언트와의 상호작용
- 요청 메서드, URL, 헤더, 본문 등의 정보를 확인하고, 적절한 응답을 반환
- 서버의 포트 설정이나 호스트 지정, 에러 처리 등의 추가적인 설정 방법에 대해서도 다룰 것 / 서버를 실행하기 전에 필요한 설정을 적용하여 원하는 동작을 수행

3. 서버를 실행하여 실제로 동작하는 HTTP 서버를 확인하고, 클라이언트에서 해당 서버에 요청을 보내 응답을 받는 과정을 체험
- 웹 브라우저나 API 도구 등을 사용하여 서버의 응답을 확인하고, 클라이언트와 서버 간의 상호작용을 확인

Node.js에서 HTTP 모듈을 사용하여 간단한 서버를 만드는 예제 코드
- 클라이언트로부터 HTTP 요청을 받고, 해당 요청에 대한 응답을 반환하는 기본적인 서버 동작

const http = require('http');

// 서버 생성
const server = http.createServer((req, res) => {
  // 요청 처리
  if (req.url === '/') {
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.end('Hello, World!');
  } else if (req.url === '/about') {
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.end('About Page');
  } else {
    res.writeHead(404, { 'Content-Type': 'text/plain' });
    res.end('Not Found');
  }
});

// 서버 실행
server.listen(3000, 'localhost', () => {
  console.log('Server is running on http://localhost:3000');
});

http 모듈을 사용하여 서버를 생성하고, 요청에 따라 적절한 응답을 반환하는 간단한 예제
http.createServer() 메서드를 사용하여 콜백 함수를 등록하고, 이 함수는 클라이언트로부터의 요청을 처리하고 응답을 반환
"/" 경로로 요청을 보내면 "Hello, World!"를 응답으로 반환
"/about" 경로로 요청을 보내면 "About Page"를 응답으로 반환
그 외의 경로로 요청을 보내면 "Not Found"를 응답으로 반환

서버가 요청을 받으면, 응답 객체인 res를 통해 클라이언트로 응답을 보낼 수 있음
res.writeHead() 메서드를 사용하여 응답의 상태 코드와 헤더를 설정하고, res.end() 메서드를 사용하여 응답의 본문을 전송

서버는 localhost의 3000번 포트에서 실행
server.listen() 메서드를 사용하여 서버를 시작하고, 콘솔에 "Server is running on http://localhost:3000" 메시지를 출력
이후 브라우저나 API 도구 등을 사용하여 해당 URL에 접속하면 서버의 응답을 확인

1) http 모듈의 속성
http.STATUS_CODES : HTTP 상태 코드와 상태 메시지를 포함하는 객체 / 예를 들어, 200은 OK, 404는 Not Found와 같이 상태 코드와 해당하는 상태 메시지를 확인
http.globalAgent : 글로벌 HTTP 에이전트 객체 / 기본적으로 모든 HTTP 요청에 사용되는 기본 에이전트
http.METHODS : HTTP 요청 메소드를 나타내는 배열 / GET, POST, PUT, DELETE 등의 요청 메소드를 확인
http.CLIENT_REQUEST : 클라이언트 HTTP 요청 클래스 / http.request()와 http.get() 함수를 호출할 때 사용되는 클래스
http.SERVER_RESPONSE : 서버 HTTP 응답 클래스 / 서버에서 클라이언트에게 응답을 보낼 때 사용되는 클래스
http.IncomingMessage : HTTP 요청 메시지 클래스 / HTTP 요청에 대한 정보와 요청 바디를 읽을 수 있는 클래스
http.Server : HTTP 서버 클래스 / http.createServer() 메소드로 생성된 서버 인스턴스
http.Agent : HTTP 요청을 관리하는 에이전트 클래스 / 커스텀 에이전트를 생성하거나 기본적으로 제공되는 글로벌 에이전트를 사용
http.Agent.defaultMaxSockets : 에이전트가 동시에 유지할 수 있는 최대 소켓 연결 수를 제어하는 속성 / 기본값은 Infinity로 설정
http.Agent.globalAgent : 글로벌 HTTP 에이전트 객체 / http.globalAgent와 동일한 객체

속성들은 HTTP 통신에서 중요한 역할을 수행
상태 코드와 상태 메시지를 확인하고, 기본 에이전트를 사용하거나 커스텀 에이전트를 생성하여 HTTP 요청을 관리
요청 메소드, 요청과 응답 클래스를 사용하여 HTTP 요청과 응답을 처리

http 모듈의 속성에 대한 사용 예시

1. http.STATUS_CODES
HTTP 상태 코드와 상태 메시지를 포함하는 객체
특정 상태 코드에 대한 메시지를 확인

const http = require('http');

console.log(http.STATUS_CODES[200]); // 200 OK
console.log(http.STATUS_CODES[404]); // 404 Not Found

2. http.globalAgent
글로벌 HTTP 에이전트 객체
기본적으로 모든 HTTP 요청에 사용되는 기본 에이전트
HTTP 요청의 에이전트 설정을 변경

const http = require('http');

http.globalAgent.maxSockets = 10; // 최대 소켓 연결 수를 10개로 설정

3. http.METHODS
HTTP 요청 메소드를 나타내는 배열
지원되는 HTTP 메소드를 확인

const http = require('http');

console.log(http.METHODS); // [ 'GET', 'POST', 'PUT', 'DELETE', ... ]

4. http.ClientRequest
클라이언트 HTTP 요청 클래스
HTTP 요청을 생성하고 서버로 보낼 수 있음

const http = require('http');

const options = {
  hostname: 'www.example.com',
  port: 80,
  path: '/',
  method: 'GET'
};

const req = http.request(options, (res) => {
  console.log(`STATUS: ${res.statusCode}`);
  console.log(`HEADERS: ${JSON.stringify(res.headers)}`);

  res.setEncoding('utf8');
  res.on('data', (chunk) => {
    console.log(`BODY: ${chunk}`);
  });
});

req.on('error', (e) => {
  console.error(`problem with request: ${e.message}`);
});

req.end();

5. http.ServerResponse
서버 HTTP 응답 클래스
서버에서 클라이언트에게 응답을 보낼 수 있음

const http = require('http');

const server = http.createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello, World!');
});

server.listen(3000, '127.0.0.1', () => {
  console.log('Server running at http://127.0.0.1:3000/');
});

6. http.IncomingMessage
클라이언트에서 서버로 전송되는 HTTP 요청 메시지나 서버에서 클라이언트로 전송되는 HTTP 응답 메시지를 나타내는 객체
요청 또는 응답의 헤더, 상태 코드, 데이터 등을 확인

const http = require('http');

const server = http.createServer((req, res) => {
  console.log(req.method); // HTTP 요청 메소드 (GET, POST 등)
  console.log(req.url); // 요청 URL
  console.log(req.headers); // 요청 헤더
  console.log(req.statusCode); // 응답 상태 코드
  console.log(req.statusMessage); // 응답 상태 메시지
});

server.listen(3000, '127.0.0.1', () => {
  console.log('Server running at http://127.0.0.1:3000/');
});

7. http.Server
HTTP 서버를 생성하기 위한 클래스
서버를 생성하고 클라이언트의 요청을 처리

const http = require('http');

const server = http.createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello, World!');
});

server.listen(3000, '127.0.0.1', () => {
  console.log('Server running at http://127.0.0.1:3000/');
});

8. http.Agent
HTTP 클라이언트에서 사용되는 에이전트를 나타내는 클래스
HTTP 연결 관리를 담당하며, 여러 개의 요청을 동시에 처리할 수 있도록 도와줌

const http = require('http');

const agent = new http.Agent({ keepAlive: true, maxSockets: 10 });

const options = {
  hostname: 'www.example.com',
  port: 80,
  path: '/',
  method: 'GET',
  agent: agent // 에이전트 설정
};

const req = http.request(options, (res) => {
  // 요청 처리
});

req.end();

9. http.Agent.defaultMaxSockets
기본적으로 각 에이전트가 유지하는 최대 소켓 연결 수를 나타내는 속성
Infinity 값을 변경하여 에이전트가 유지하는 소켓 연결 수를 제한

const http = require('http');

console.log(http.Agent.defaultMaxSockets); // 기본값 출력

http.Agent.defaultMaxSockets = 5; // 최대 소켓 연결 수를 5개로 설정

10. http.Agent.globalAgent
글로벌 HTTP 에이전트 객체를 나타내는 속성
기본 에이전트의 설정을 변경

const http = require('http');

http.globalAgent.maxSockets = 10; // 최대 소켓 연결 수를 10개로 설정

2) http 모듈의 메소드
http.createServer()
- HTTP 서버를 생성하는 메소드 / 서버를 생성하고 클라이언트의 요청을 처리
http.request()
- HTTP 요청을 생성하는 메소드 / 클라이언트가 서버로 HTTP 요청을 보낼 수 있음
http.get()
- HTTP GET 요청을 생성하는 메소드 / 간단하게 GET 요청을 보낼 수 있음
http.createServer() 메소드와 함께 사용되는 request 이벤트
- 서버에서 클라이언트의 HTTP 요청을 처리하기 위한 이벤트
http.createServer() 메소드와 함께 사용되는 listening 이벤트
- 서버가 리스닝 상태에 들어갔을 때 발생하는 이벤트
http.IncomingMessage
- HTTP 요청에 대한 정보를 담고 있는 객체
http.ServerResponse
- HTTP 응답을 처리하는 객체
http.METHODS
- HTTP 메소드의 배열을 반환 / 지원되는 HTTP 메소드를 확인
http.STATUS_CODES
- HTTP 상태 코드와 해당하는 상태 메시지를 담고 있는 객체
http.Agent
- HTTP 요청을 관리하는 에이전트 객체
http.globalAgent
- 전역적으로 사용되는 기본 HTTP 에이전트 객체
http.createServer() 메소드와 함께 사용되는 close 이벤트
- 서버가 종료되었을 때 발생하는 이벤트
http.createServer() 메소드와 함께 사용되는 checkContinue 이벤트
- 클라이언트가 지속적인 요청을 보낼 때 발생하는 이벤트
http.createServer() 메소드와 함께 사용되는 connect 이벤트
- 클라이언트가 CONNECT 메소드로 요청을 보낼 때 발생하는 이벤트
http.createServer() 메소드와 함께 사용되는 upgrade 이벤트
- 클라이언트가 업그레이드 요청을 보낼 때 발생하는 이벤트
http.get() 메소드와 함께 사용되는 error 이벤트
- GET 요청 중에 오류가 발생했을 때 발생하는 이벤트
http.IncomingMessage 객체의 headers 속성
- 수신된 HTTP 요청 헤더 정보를 담고 있는 속성
http.IncomingMessage 객체의 url 속성
- 수신된 HTTP 요청의 URL 정보를 담고 있는 속성
http.ServerResponse 객체의 writeHead() 메소드
- HTTP 응답의 상태 코드와 헤더를 설정하는 메소드
http.ServerResponse 객체의 end() 메소드
- HTTP 응답을 종료하는 메소드

Node.js http 모듈의 메소드와 이벤트에 대한 사용 예시

1. http.createServer()
const http = require('http');

// HTTP 서버 생성
const server = http.createServer((req, res) => {
  // 클라이언트 요청 처리
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello, world!');
});

// 서버가 리스닝 상태에 들어갔을 때 이벤트 처리
server.listen(3000, 'localhost', () => {
  console.log('서버가 3000번 포트에서 리스닝 중입니다.');
});

2. http.request()
const http = require('http');

// HTTP 요청 생성
const options = {
  hostname: 'www.example.com',
  port: 80,
  path: '/api/data',
  method: 'GET'
};

const req = http.request(options, (res) => {
  console.log(`상태 코드: ${res.statusCode}`);

  res.on('data', (chunk) => {
    console.log(`데이터 수신: ${chunk}`);
  });

  res.on('end', () => {
    console.log('요청 완료');
  });
});

req.on('error', (error) => {
  console.error(`요청 오류: ${error.message}`);
});

req.end();

3. http.get()
const http = require('http');

// HTTP GET 요청 생성
http.get('http://www.example.com', (res) => {
  console.log(`상태 코드: ${res.statusCode}`);

  res.on('data', (chunk) => {
    console.log(`데이터 수신: ${chunk}`);
  });

  res.on('end', () => {
    console.log('요청 완료');
  });
}).on('error', (error) => {
  console.error(`요청 오류: ${error.message}`);
});

4. http.createServer() 메소드와 함께 사용되는 request 이벤트
const http = require('http');

// HTTP 서버 생성
const server = http.createServer((req, res) => {
  // 클라이언트 요청 처리
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello, world!');
});

// 클라이언트의 HTTP 요청을 처리하기 위한 이벤트
server.on('request', (req, res) => {
  console.log('클라이언트 요청이 들어왔습니다.');
});

server.listen(3000, 'localhost', () => {
  console.log('서버가 3000번 포트에서 리스닝 중입니다.');
});

5. http.createServer() 메소드와 함께 사용되는 listening 이벤트
const http = require('http');

// HTTP 서버 생성
const server = http.createServer((req, res) => {
  // 클라이언트 요청 처리
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello, world!');
});

// 서버가 리스닝 상태에 들어갔을 때 이벤트 처리
server.on('listening', () => {
  console.log('서버가 리스닝 상태에 들어갔습니다.');
});

server.listen(3000, 'localhost', () => {
  console.log('서버가 3000번 포트에서 리스닝 중입니다.');
});

6. http.IncomingMessage
const http = require('http');

const server = http.createServer((req, res) => {
  // IncomingMessage 객체를 사용하여 요청 정보 확인
  console.log(req.method); // HTTP 메소드 (GET, POST 등)
  console.log(req.url); // 요청 URL
  console.log(req.headers); // 요청 헤더
});

server.listen(3000, 'localhost', () => {
  console.log('서버가 3000번 포트에서 리스닝 중입니다.');
});

7. http.ServerResponse
const http = require('http');

const server = http.createServer((req, res) => {
  // ServerResponse 객체를 사용하여 응답 처리
  res.statusCode = 200; // 응답 상태 코드
  res.setHeader('Content-Type', 'text/plain'); // 응답 헤더 설정
  res.end('Hello, world!'); // 응답 데이터 전송
});

server.listen(3000, 'localhost', () => {
  console.log('서버가 3000번 포트에서 리스닝 중입니다.');
});

8. http.METHODS
const http = require('http');

console.log(http.METHODS); // 지원되는 HTTP 메소드의 배열 출력

9. http.STATUS_CODES
const http = require('http');

console.log(http.STATUS_CODES); // HTTP 상태 코드와 메시지를 담고 있는 객체 출력
console.log(http.STATUS_CODES[200]); // 200 상태 코드에 해당하는 메시지 출력

10. http.Agent
const http = require('http');

const agent = new http.Agent({ keepAlive: true, maxSockets: 10 });

const options = {
  hostname: 'www.example.com',
  port: 80,
  path: '/',
  method: 'GET',
  agent: agent // 에이전트 설정
};

const req = http.request(options, (res) => {
  // 요청 처리
});

req.end();

11. http.globalAgent
const http = require('http');

const options = {
  hostname: 'www.example.com',
  port: 80,
  path: '/',
  method: 'GET',
  agent: http.globalAgent // 전역적으로 사용되는 기본 HTTP 에이전트 객체
};

const req = http.request(options, (res) => {
  // 요청 처리
});

req.end();

12. http.createServer() 메소드와 함께 사용되는 close 이벤트
const http = require('http');

const server = http.createServer((req, res) => {
  // 서버 요청 처리
  res.end('Hello, world!');
});

server.on('close', () => {
  console.log('서버가 종료되었습니다.');
});

server.listen(3000, 'localhost', () => {
  console.log('서버가 3000번 포트에서 리스닝 중입니다.');
});

// 서버 종료
server.close();

13. http.createServer() 메소드와 함께 사용되는 checkContinue 이벤트
const http = require('http');

const server = http.createServer((req, res) => {
  // 클라이언트가 지속적인 요청을 보낼 때 이벤트 처리
  res.writeContinue(); // 클라이언트에게 계속 진행하도록 응답

  // 나머지 요청 처리
  res.end('Hello, world!');
});

server.listen(3000, 'localhost', () => {
  console.log('서버가 3000번 포트에서 리스닝 중입니다.');
});

14. http.createServer() 메소드와 함께 사용되는 connect 이벤트
const http = require('http');

const server = http.createServer((req, res) => {
  // 클라이언트가 CONNECT 메소드로 요청을 보낼 때 이벤트 처리
  res.write('HTTP/1.1 200 Connection Established\r\n' +
             'Proxy-agent: Node.js-Proxy\r\n' +
             '\r\n');
  res.pipe(res);
});

server.listen(3000, 'localhost', () => {
  console.log('서버가 3000번 포트에서 리스닝 중입니다.');
});

15. http.createServer() 메소드와 함께 사용되는 upgrade 이벤트
const http = require('http');

const server = http.createServer((req, res) => {
  // 클라이언트가 업그레이드 요청을 보낼 때 이벤트 처리
  res.write('HTTP/1.1 101 Switching Protocols\r\n' +
             'Upgrade: websocket\r\n' +
             'Connection: Upgrade\r\n' +
             '\r\n');
  res.pipe(res);
});

server.listen(3000, 'localhost', () => {
  console.log('서버가 3000번 포트에서 리스닝 중입니다.');
});

16. http.get() 메소드와 함께 사용되는 error 이벤트
const http = require('http');

const req = http.get('http://www.example.com', (res) => {
  // 요청 처리
});

req.on('error', (error) => {
  // GET 요청 중에 오류가 발생했을 때 이벤트 처리
  console.error(`오류 발생: ${error.message}`);
});

req.end();

17. http.IncomingMessage 객체의 headers 속성
const http = require('http');

const server = http.createServer((req, res) => {
  // 수신된 HTTP 요청 헤더 정보 확인
  console.log(req.headers);
});

server.listen(3000, 'localhost', () => {
  console.log('서버가 3000번 포트에서 리스닝 중입니다.');
});

18. http.IncomingMessage 객체의 url 속성
const http = require('http');

const server = http.createServer((req, res) => {
  // 수신된 HTTP 요청의 URL 정보 확인
  console.log(req.url);
});

server.listen(3000, 'localhost', () => {
  console.log('서버가 3000번 포트에서 리스닝 중입니다.');
});

19. http.ServerResponse 객체의 writeHead() 메소드
const http = require('http');

const server = http.createServer((req, res) => {
  // HTTP 응답의 상태 코드와 헤더 설정
  res.writeHead(200, { 'Content-Type': 'text/plain' });

  // 나머지 응답 처리
  res.end('Hello, world!');
});

server.listen(3000, 'localhost', () => {
  console.log('서버가 3000번 포트에서 리스닝 중입니다.');
});

20. http.ServerResponse 객체의 end() 메소드
const http = require('http');

const server = http.createServer((req, res) => {
  // 응답 데이터 전송 후 HTTP 응답 종료
  res.end('Hello, world!');
});

server.listen(3000, 'localhost', () => {
  console.log('서버가 3000번 포트에서 리스닝 중입니다.');
});

참고해서 파악하면 좋은 메소드
http.createServer()
http.request()
http.get()
request 이벤트
listening 이벤트
http.IncomingMessage
http.ServerResponse
http.METHODS
http.STATUS_CODES
http.Agent
http.globalAgent
close 이벤트
checkContinue 이벤트
connect 이벤트
upgrade 이벤트
http.get() 메소드와 함께 사용되는 error 이벤트
http.IncomingMessage 객체의 headers 속성
http.IncomingMessage 객체의 url 속성
http.ServerResponse 객체의 writeHead() 메소드
http.ServerResponse 객체의 end()