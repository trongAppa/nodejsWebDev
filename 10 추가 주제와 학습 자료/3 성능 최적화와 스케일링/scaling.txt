성능 최적화와 스케일링

1) 성능 최적화
- 코드 최적화 : 비효율적인 코드를 개선하고, 성능에 영향을 주는 부분을 식별하여 최적화
- 비동기 프로그래밍 : 비동기 패턴을 사용하여 I/O 작업을 효율적으로 처리하고, 블로킹 작업을 최소화
- 메모리 관리 : 메모리 누수를 방지하고, 메모리 사용을 최적화하여 성능을 향상
- 캐싱 : 데이터나 계산 결과를 캐싱하여 불필요한 작업을 피하고, 처리 속도를 높임
- 모듈 최적화 : 필요한 모듈만 사용하고, 불필요한 모듈을 제거하여 번들 크기를 줄이고 성능을 개선

2) 스케일링
- 수직적 스케일링 : 단일 서버의 성능을 향상시키기 위해 CPU, 메모리, 디스크 등의 리소스를 업그레이드
- 수평적 스케일링 : 여러 대의 서버를 추가하여 부하를 분산시키고, 확장성을 향상
- 로드 밸런싱 : 로드 밸런서를 사용하여 트래픽을 여러 서버로 분산시켜 성능과 가용성을 향상
- 클러스터링 : 여러 대의 서버를 클러스터로 구성하여 고가용성과 확장성을 제공
- 캐싱과 CDN 활용 : 캐싱 기법과 CDN(Content Delivery Network)을 활용하여 정적 리소스를 효율적으로 제공

3) 학습 자료
- "Node.js 성능 최적화" (저자: Colin Ihrig) : Node.js 애플리케이션의 성능 최적화 방법과 도구 사용법을 다루는 책
- Node.js 공식 문서 (https://nodejs.org/ko/docs/guides/) : Node.js 공식 문서의 성능 관련 가이드와 최적화 기법을 제공
- Scaling Node.js 어플리케이션 (https://nodejs.org/en/docs/guides/scaling-howto/) : Node.js 어플리케이션을 확장하고 스케일링하는 방법을 설명하는 공식 문서 가이드

1. 메모리 관리

// 메모리 누수를 방지하기 위해 변수를 null로 설정하여 참조를 해제합니다.
let data = loadData(); // 어떤 데이터를 로드하는 함수
// 데이터 처리 작업
data = null;

// 큰 데이터를 다룰 때는 스트림을 사용하여 메모리 사용을 최적화할 수 있습니다.
const fs = require('fs');
const readStream = fs.createReadStream('largeFile.txt');
readStream.on('data', (chunk) => {
  // 데이터 처리
});
readStream.on('end', () => {
  // 작업 완료 후 처리
});

// 필요한 경우 메모리 사용량을 모니터링하고 관리합니다.
const used = process.memoryUsage();
console.log(`메모리 사용량: ${Math.round(used.heapUsed / 1024 / 1024 * 100) / 100} MB`);

// 큰 데이터 구조를 사용할 때는 메모리 해제를 고려합니다.
let largeData = loadData(); // 큰 데이터를 로드하는 함수
// 작업 완료 후 메모리 해제
largeData = null;

변수 null로 설정 : 데이터 처리가 끝난 후 변수를 null로 설정하여 해당 데이터에 대한 참조를 해제 / 가비지 컬렉터가 해당 메모리를 회수
스트림 사용 : 큰 파일이나 데이터를 처리할 때는 스트림을 사용하여 한 번에 모든 데이터를 메모리에 로드하지 않고, 조각 단위로 처리 / 메모리 사용을 최적화
메모리 사용량 모니터링: process.memoryUsage()를 사용하여 현재 메모리 사용량을 모니터링 / 메모리 누수나 과도한 메모리 사용을 감지하고 조치
메모리 해제: 큰 데이터 구조를 사용한 작업이 끝나면 해당 데이터에 대한 참조를 해제하여 메모리를 해제

메모리 관리 기법은 Node.js 애플리케이션에서 메모리 사용을 최적화하고 메모리 누수를 방지하는데 도움

2. 캐싱

const cache = {};

function getDataFromCache(key) {
  if (cache[key]) {
    console.log(`캐시에서 데이터를 가져옵니다. ${key}`);
    return cache[key];
  } else {
    console.log(`캐시에 데이터가 없으므로 새로운 데이터를 가져옵니다. ${key}`);
    const data = fetchDataFromDatabase(key); // 데이터를 가져오는 함수 (예시)
    cache[key] = data; // 데이터를 캐시에 저장
    return data;
  }
}

// 데이터를 가져오는 예시 함수
function fetchDataFromDatabase(key) {
  console.log(`데이터베이스에서 데이터를 가져옵니다. ${key}`);
  // 데이터를 가져오는 로직
  return `데이터: ${key}`;
}

// 데이터 캐싱을 사용하는 예시
console.log(getDataFromCache("A")); // 데이터베이스에서 데이터를 가져옵니다. A
// 첫 번째 호출은 데이터베이스에서 데이터를 가져옵니다.

console.log(getDataFromCache("A")); // 캐시에서 데이터를 가져옵니다. A
// 두 번째 호출부터는 캐시에서 데이터를 가져옵니다.

console.log(getDataFromCache("B")); // 데이터베이스에서 데이터를 가져옵니다. B
// B는 캐시에 없으므로 데이터베이스에서 가져옵니다.

console.log(getDataFromCache("B")); // 캐시에서 데이터를 가져옵니다. B
// 두 번째 호출부터는 캐시에서 데이터를 가져옵니다.

cache 객체 : 데이터를 캐싱하기 위한 객체 / 메모리에 데이터를 저장하는 역할
getDataFromCache 함수 : 데이터를 캐시에서 가져오는 함수 / cache 객체에 해당 키(key)가 있는지 확인하여 데이터가 캐시에 있는 경우 캐시에서 데이터를 반환 / 캐시에 데이터가 없는 경우 fetchDataFromDatabase 함수를 호출하여 데이터를 가져온 후 cache 객체에 저장하고 반환
fetchDataFromDatabase 함수 : 데이터를 가져오는 예시 함수 / 데이터베이스에서 데이터를 가져오는 로직을 포함

첫 번째 호출은 데이터베이스에서 데이터를 가져옴
두 번째 호출부터는 캐시에서 데이터를 가져옴
동일한 데이터에 대한 반복적인 데이터베이스 접근을 피하고, 처리 속도를 향상

데이터의 유효성 기간과 캐시의 사이즈 관리 등을 고려하여 캐싱을 구현
캐싱을 이해하는 데 도움을 주기 위한 기본적인 예시

3. 모듈 최적화

Node.js에서 모듈 최적화를 적용하는 예제

// main.js

// 필요한 모듈만 로드합니다.
const { getUserData } = require('./user');
const { getProductData } = require('./product');

// 사용자 데이터를 가져옵니다.
const userData = getUserData();
console.log(userData);

// 상품 데이터를 가져옵니다.
const productData = getProductData();
console.log(productData);
// user.js

// 필요한 데이터를 가져오는 함수
function getUserData() {
  // 사용자 데이터를 가져오는 로직
  return '사용자 데이터';
}

// 필요한 함수만 export 합니다.
module.exports = {
  getUserData
};
// product.js

// 필요한 데이터를 가져오는 함수
function getProductData() {
  // 상품 데이터를 가져오는 로직
  return '상품 데이터';
}

// 필요한 함수만 export 합니다.
module.exports = {
  getProductData
};

모듈 최적화 기법을 사용

필요한 모듈만 로드 : main.js에서 필요한 모듈만 require를 사용하여 로드 / 불필요한 모듈의 로드를 방지하여 메모리와 리소스를 절약
모듈 분리 : 관련된 기능을 가진 모듈들을 분리하여 개별 파일로 작성 / user.js와 product.js 모듈이 각각 사용자 데이터와 상품 데이터를 가져오는 역할을 수행 / 코드의 가독성과 관리성을 향상

main.js에서 필요한 모듈만 로드
해당 모듈에서 필요한 데이터를 가져와 출력
모듈 최적화를 적용하여 필요한 리소스만 사용하고, 불필요한 리소스 낭비를 방지

실제로는 애플리케이션의 규모와 구조에 맞게 모듈을 분리하고 필요한 모듈만 로드하는 방식으로 최적화를 적용