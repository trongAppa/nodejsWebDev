콜백 지옥과 콜백 헬 방지 방법
콜백 지옥(callback hell)
- 콜백 함수를 중첩하여 사용할 때 코드가 복잡해지고 가독성이 저하되는 현상
- 비동기 작업이 많이 포함된 코드에서는 콜백 함수의 중첩이 깊어질 수 있으며, 이로 인해 코드의 이해와 유지보수가 어려워짐

콜백 지옥을 해결하기 위한 방법
- 콜백 헬을 피하기 위해 콜백 함수를 외부로 분리
 - 비동기 작업의 결과를 처리하는 콜백 함수를 따로 정의하고, 해당 함수를 콜백으로 사용
 - 코드의 가독성을 향상
- 프로미스(Promise)를 활용 
 - 프로미스는 비동기 작업의 성공 또는 실패를 나타내는 객체로, 콜백 함수를 사용하는 대신 then()과 catch() 메서드를 활용하여 비동기 작업
 - 프로미스를 사용하면 비동기 코드의 가독성을 높일 수 있음
- async/await 문법을 사용
 - 비동기 작업을 동기적인 코드처럼 작성할 수 있게 해주는 문법
 - async 키워드로 비동기 함수를 선언하고, await 키워드를 사용하여 비동기 작업의 결과를 기다릴 수 있음
 - 코드의 가독성과 이해도를 향상

콜백 지옥을 방지하는 방법
- 코드의 가독성과 유지보수성을 향상시키는 데 중요
- 콜백 함수의 외부 분리, 프로미스, async/await 문법 등을 적절히 활용하여 비동기 코드를 더 간결하고 가독성 있게 작성할 수 있음
- 코드의 복잡성을 줄이고 개발 생산성을 향상

예제 코드

1. 콜백 함수를 외부로 분리하기
// 비동기 작업을 수행하는 함수
function asyncTask(callback) {
  setTimeout(() => {
    const result = '비동기 작업 완료';
    callback(result);
  }, 1000);
}

// 결과를 처리하는 콜백 함수
function handleResult(result) {
  console.log(result);
}

// 콜백 함수를 외부로 분리하여 사용
asyncTask(handleResult);

2. 프로미스(Promise) 활용하기
// 비동기 작업을 수행하는 함수 (프로미스 반환)
function asyncTask() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const result = '비동기 작업 완료';
      resolve(result);
    }, 1000);
  });
}

// 비동기 작업 처리
asyncTask()
  .then((result) => {
    console.log(result);
  })
  .catch((error) => {
    console.error(error);
  });

3. async/await 문법 사용하기
// 비동기 작업을 수행하는 함수 (프로미스 반환)
function asyncTask() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const result = '비동기 작업 완료';
      resolve(result);
    }, 1000);
  });
}

// 비동기 작업 처리
async function handleAsyncTask() {
  try {
    const result = await asyncTask();
    console.log(result);
  } catch (error) {
    console.error(error);
  }
}

handleAsyncTask();